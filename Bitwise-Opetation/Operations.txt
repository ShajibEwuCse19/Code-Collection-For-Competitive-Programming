=====================================================================================================================================================================
-> যখন বাইনারি নাম্বার নিয়ে কাজ করবো, তখন সব অপারেশন বাইনারিতেই করবো। বাইনারির কোন প্রব্লেমে ডেসিমাল নাম্বার নিয়ে অপারেশন করে সলিউশন বের করবো না।  যেমন, ২টা সংখ্যার 
XOR বের করে ১ বিয়োগ করতে হবে, এখনে সম্পূর্ণ সলিউশন বাইনারি সংখ্যা দিয়েই বের করবো। ডেসিমাল নিয়ে প্রথমেই চিন্তা করা যাবে না। 

Decimal to Binary:
=====================================================================================================================================================================
Let, n = 16.
we'll divided n by 2 untill it's greater than 0. 

while (n>0)n = n/2;

16->8->4->2->1->0 = 0 0 0 0 1 (reminder) is the binary number of decimal 16.

Binary to Decimal:
=====================================================================================================================================================================
Let, n = 1101.01
sizeof(n) = 4

ans = (1x2^3) + (1x2^2) + (1x2^1) + (1x2^0) (1x2^-1) + (1x2^-2) = 8 + 4 + 2 + 1 + 0 + 0.25 = 13.25 //2^0 = 1.
13.25 is the decimal form of n.

Exercise: প্রত্যেক সংখ্যাকে কিছু distinct ২ এর power এর summation আকারে লিখতে হবে ।
Answer  : বাইনারি থেকে ডেসিমালে রূপান্তর করলে আমরা ২এর যে power পাই তার সব গুলোই 0 থেকে sizeof(n) এর সমান। সব গুলোই distinct. বাইনারি থেকে ডেসিমালে কনভার্ট করলেই উত্তর।

Exercise: কোন সংখ্যাকে সর্বোচ্চ কতটি ২ এর পাওয়ার হিসেবে লিখতে পারি ?
Answer  : Let, n = 5 = 2^0 + 2^2 = 1 + 4 = 5 (ans = 2).
Let n = 7 = 2^0 + 2^1 + 2^2 = 1 + 2 + 4 = 7 (ans = 3).
Let , total power = x.

Now, 2^x = n 
   => log2^x = log(n)
   => xlog2 = log(n)
   
if, n = 5 , log(5) = 2.5 // so, ans = floor(2.5) = 2
if, n = 7, log(7)  = 3.
log(2x10^8) = 32 (MAX_INT).
log(2x10^18) = 64 (LONG_MAX_INT).

==> log(n)base (b) = log(n)/log(b) [Avoid Fractions]
log(5) = log(5)/log(2) [for 2 base log]

Left-Shift(<<):
=====================================================================================================================================================================
কোন সংখ্যাকে দ্বিগুণ করে । যে্মন, 5<<1 = 5x2 = 10
Explanation: 5 = 101 in binary = 00000101. (শেষ থেকে ১ এর অবস্থান ৩নাম্বার)।
             5<<1 = 1010       = 00001010.  (এক ঘর বামে আসায় শেষ এ  ০ যোগ এবং এক এর অবস্থান শেষ থেকে ৪ এ)। 
             
right-Shift(>>):Opposite of left-shift
=====================================================================================================================================================================
কোন সংখ্যাকে 2ভাগ বা অর্ধেক করে । যে্মন, 5>>1 = 5/2 = 2.5
Explanation: 5 = 101 in binary = 00000101. (শেষ থেকে ১ এর অবস্থান ৩নাম্বার)।
             5<<1 = 1010       = 00000010.  (এক ঘর ডানে আসায় শেষ এর এক উঠে যাবে এবং সব সংখ্যা এক ঘর ডানে সরে যাবে)। 
             
 Bitwise OR (|):
 =====================================================================================================================================================================
 1 | 1 = 1
 1 | 0 = 1
 0 | 1 = 1
 0 | 0 = 0
 
 5 = 101, 8 = 1000.
 5|8 = 1101 = 13 (5 + 8 = 13).
 12|4 = 12  (12 + 4 not equal 12).
 
 So, min(a|b) = max(a,b).
     max(a|b) = (a+b).
     
 
 Exercise: কিভাবে একটি নির্দিষ্ট পজিশনের বিট ON(Only convert 0 to 1) করতে পারি ?
 => Let, n = 12 = 1100. (We want to turn on 2nd bit from last position).
 position = 1 (3 2 1 0 is Array index in reverse order = sizeof(1100) string)
 a = 1<<position = 1<<1 = 10.
 
 Now,
       n = 1 1 0 0
       a = 0 0 1 0 (1<<pos)
 ---------------------------------------
    n|a  = 1 1 1 0 (Turn on 2nd index).
 
 Answer = n|(1<<position).
 
 Bitwise AND(&):
 =====================================================================================================================================================================
 1 & 1 = 1
 1 & 0 = 0
 0 & 1 = 0
 0 & 0 = 0
 
 min(a & b) = 0
 max(a & b) = min(a,b).
 
 Exercise: কিভাবে একটি নির্দিষ্ট পজিশনের বিট OFF(Only convert 1 to 0) করতে পারি ?
 n = 10101, we'll make 1 (2nd position in array reverse order ).
 
 a = 1<<position = 1<<2 = 00100;
 
    n = 1 0 1 0 1
    a = 0 0 1 0 0
---------------------------
a & n = 0 0 1 0 0 (Wrong because সব অফ হয়ে গেছে ).
 
 a = 00100.
 NOT(a) = ~a = 11011
 
 Now,
      n = 1 0 1 0 1
     ~a = 1 1 0 1 1
 ----------------------------------
n & ~a  = 1 0 0 0 1 
 
 Answer : n & (~(1<<position)).
 
 Exercise: কোন একটি পজিশন ০ নাকি ১ ?
 => a = 1 0 1 0 1 (find for 2nd position)
    b = 0 0 1 0 0 (1<<position)
-----------------------------------------------
a & b = 0 0 1 0 0 (if 2nd position = 1 then ans = 1 else ans = 0). Here 2nd pos = 1 . so, ans = 1. 

Bitwise X-OR(^):
=====================================================================================================================================================================
 1 ^ 1 = 0
 1 ^ 0 = 1
 0 ^ 1 = 1
 0 ^ 0 = 0
 
 Exercise: Sum of two numbers.
 =>       a = 21 = 1 0 1 0 1
          b = 27 = 1 1 0 1 1
-----------------------------------------------
   a ^ b         = 0 1 1 1 0 = 14
   a & b         = 1 0 0 0 1 = 17
  2(a & b) = 2x17            = 34
  
  sum = 14 + 34 = 48 = 21 + 27.
  
  Answer: Sum of two numbers = (a ^ b) + (2*(a & b))
  
  Exercise: if a^b^c^d = x,then a^c^d = ?
  => Let, a^b^c = y
  
  Now, (a^b^c^d)^b = (a^c^d)^(b^b) = a^c^d [b^b = 0]
  
  
  Exercise: শেষের ২ঘরের বিট flip (উল্টানো)  করতে হব ? ০ থাকলে ১ , ১ থাকলে ০ বানাতে হবে । 
  => Let, n = 1 0 1 1
  sizeof(n) = 4
  
      let, a(1<<2) = 0 0 1 0 0 (0 to 2 index).
                           - 1
  -------------------------------------------------------
  (1<<2)-1         = 0 0 0 1 1 [bitwise minus]
         n         = 0 1 0 1 1
---------------------------------------------------------
n^((1<<2)-1)       = 0 1 0 0 0

Answer : n^((1<<position)-1)




Build In function:
=====================================================================================================================================================================
__builtin_popcount( n ) -> No of 1 in binary representation of n.
__builtin_clz( n ) -> count Leading zero.
__builtin_ctz( n ) -> count tailing zero.

IF n = 11,
   n = 11 = 0111 (in Binary), Here, No of 1 = 3, Leading zero = 31 - 3 = 28, Tailing zero = 0
   
   
   
   


Random Exercise:
=====================================================================================================================================================================

1. a-তম ঘরে ১ আছে কিনা ?
=> let a = 3rd index=3
 
Let, n = 1 0 1 0 0 1

n>>a = n>>3 = 0 0 0 1 0 1
                        1
-----------------------------
(n>>3) & 1  = 0 0 0 0 0 1 = 1 in decimal. So, ans = 1.

Answer:if((n>>position) & 1 == 1 ) ans = 1. else ans = 0.

2. একটি সংখ্যা জোড় নাকি বেজোড় অথবা শেষ বিট অন নাকি অফ ?
Answer: if(n & 1 == 1) ans odd / Last Bit ON
        if (n & 1 == 0) ans even / Last Bit OFF
        
        
3. How to check nth Position ON or OFF?
Ans : if ( n & ( 1 << pos ) ) = 1 (ON) = 0 (OFF), এখনে pos বিটকে ১ এর সাথে AND করে চেক করা হচ্ছে যে বিট ১ নাকি ০.
    : if ( ( n >> pos ) & 1)  = 1 (ON) = 0 (OFF), এখনে pos বিটকে শেষ পজিশনে নিয়ে এসে ১ এর সাথে AND করে চেক করা হচ্ছে যে বিট ১ নাকি ০.
  
  
 4. How to ON nth Bit?
 Ans : ( n | ( 1 << pos ) ), এখানে, এখনে pos বিটকে ১ এর সাথে OR করে চেক করা হচ্ছে। এক্ষেত্রে pos এ ১ থাকেলে তা চেঞ্জ হবে না ( ১ । ১ = ১ ), ০ থাকলে তা ১ হবে ( ১ । ০ = ১ ).
                                    OR করার কারণে pos এর বাম ডানের বিট অপরিবর্তিত থাকবে। 
                                    
 
 4. How to OFF nth Bit?
 Ans : ( n & ( ( (1LL << 30LL) - 1LL) - (1LL<<pos) ) ) = ( n AND ( (2^30 - 1) - 2^pos )
 এখানে, ( 1LL << 30 ) হচ্ছে ৩০ বিটের সংখ্যা যার ১ম বিট ১ এবং বাকি ২৯ বিট ০       = ১০০০০০০০০০০..................০
        ((1LL << 30 ) - 1) হচ্ছে ৩০ বিটের সংখ্যা যার ১ম বিট ০ এবং বাকি ২৯ বিট ১  = ০১১১১১১১১১১১১১..................১
        (1LL<<pos) হচ্ছে nth pos এ ১ বাকি সব বিট ০                              = ০০০........০০১০০০ (Let, n = 4)
        ( ( (1LL << 30LL) - 1LL) - (1LL<<pos) ) হচ্ছে nth pos এ ০ বাকি সব বিট ১ = ১১১..........১১০১১১ (Let, n = 4)
                                                                        Let, n =               ১১১০১ (4th Bit ON)
                                                                        -----------------------------------------
                                                                        AND    =               ১০১০১ (4th Bit OFF)
 5. n = 1 1 0 1 1 1 0 0, 4th বিট পর্যন্ত পরিবর্তিত থাকবে এবং বাকি সব ০ হবে? 
    n = 1 1 0 1 1 1 0 0
    x = 0 0 0 0 1 1 1 1 ( ( 1 << (pos + 1) ) - 1), Details in 4 no qstn
----------------------------
n & x = 0 0 0 0 1 1 0 0 , এখানে ৪বিট পর্যন্ত ১ এবং বাকি সব ০ নিয়ে এন্ড করলে প্রথম ৪বিট অপরিবর্তিত থাকবে। বাকি সব ০ এর সাথে AND করে ০ হয়ে যাবে।  

Ans: ( n & ( (1 << (pos+1) ) -1 ) ) অথবা, (n % 2^pos) এখানে,pos পর্যন্ত সব বিট অপরিবর্তিত থাকবে এবং তার আগের সব বিট ০ হয়ে যাবে।


6. IF n is even, then n XOR (n+1) = n ^ (n+1) = 1. example: 4^5 = 0100 ^ 0101 = 0001 = 1, 8^9 = 1, 100^101 = 1 etc.


7. N পর্যন্ত সব সংখ্যার XOR এর যোগফল কত? N সর্বোচ্চ 1e18 হতে পারে। 
=> ০ ^ 1 ^ 2 ^ 3 ^ 4 ^ 5 ^ 6 ^ 7 ^ 8 ^ 9 ^ 10 ^ ................^ N
 = (০ ^ 1) ^ (2 ^ 3) ^ (4 ^ 5) ^ (6 ^ 7) ^ (8 ^ 9) ^ (10 ^ .)..............(.^ N)
 = (1) ^ (1) ^ (1) ^ (1) ^ (1) ^ (1)..............(1) /// We Know, X^X = 0 for same number
 = 0 ^ 0 ^ 0 ^............^0 
That's mean,
0^1 = 1
2^3 = 1
but 0^1^2^3 = 1^1 = 0
Every 4 no. we'll get 0.


Ans: ( ( N % 4 ) + 1 ) no. will be ans from last. 
IF, N = 6, (6%4) + 1= 2 + 1 = 3 no will be add. ( 0^1^2^3 = 0), (4^5^6) will be ans.
    Ans = (4 ^ 5 ^ 6)
    
    
8. Is N a power of 2 ? (1,2,4,8,16 etc)
Ans: IF, __builtin_popcount(N) == 1 -> YES ( 8 = 001000 , 32 = 000100000 etc)


9. Log(N) = ? for base 2.
Ans: Position of MSB of 1. Example: 19 = 00010011 , Here MSB = 5th position for 1 (000 1 0011). So, Log(19) = 5 for base 2.
     So, 31 - __builtin_clz(19) = 5 (We'll get MSB 1 after all leading zero)
     

10. Position of LSB-1 = ? for N 
Ans: (__builtin_ctz(N) + 1 ) , Example : N = 00010001000. Ans = Tailing zero + 1 = 3 + 1 = 4 th bit LSB-1  



11. If, x XOR y = x^y = 0 then, x = y [ 1^1=0, 5^5 = 101^101 = (1^1)^(0^0)^(1^1) [bit by bit] = 0^0^0 = 0, 123^123 = 0]


12. একটা Array তে কতগুলো pair আছে যেখানে x^y = 0 ( পেয়ারের নাম্বার) হবে।
Ans: যেহেতু ২টা সমান সংখ্যার XOR = ০ হবে, তাই সম্পূর্ণ Array একটা সেট এ ইনপুট নিয়ে, এরপর ( Array Length - Set Length ) করলে উত্তর বের হবে। এখানে মূলত সমান নাম্বার গুলো বের করতে হবে।


13. একটা Array থেকে কতগুলো (Xi XOR Yj XOR Zk) = Xi ^ Yj ^ Zk = 0 বের করা সম্ভব। X,Y,Z সমান নাও হতে পারে। Example :X = 7, Y = 1 , Z = 6,Then, X^Y^Z = (7^1)^Z = 6 ^ Z = 6^6 = 0
Ans: ২টা সংখ্যার XOR যদি ৩য় সংখ্যার সমান হয় তাহলে উত্তর হ্যা। সব সংখ্যা শুরুতে ভিজিট করে রাখতে হবে। লুপ চালিয়ে ২টা সংখ্যা নিয়ে এদের XOR করে যে সংখ্যা আসে সেটি Array তে আছে কিনা 
ভিজিট Array থেকে চেক করতে হবে। 


14. X^X = 0, X^X^X = (X^X)^X = 0^X = X, X^X^X^X^ = 0^0 = 0, অর্থাৎ একটি সংখ্যাকে (X) Even সংখ্যকবার XOR করলে তা ০ হয়ে যা, Odd সংখ্যকবার করলে তা X (সংখ্যাটি) থাকে। 


15. Prefix XOR:
Array : 1 ^ 2 ^ 3 ^ 4 ^ 5, এখানে (3^4^5) এর XOR কিভাবে বের করা যাবে?
Ans: (1 ^ 2 ^ 3 ^ 4 ^ 5) ^ ( 1 ^ 2) = (1 ^ 1) ^ (2 ^ 2) ^ ( 3 ^ 4 ^ 5) = 0 ^ 0 ^ 3 ^ 4 ^ 5 = answer. যে SubArray এর XOR বের করতে হবে সেটি ছাড়া বাকি অংশগুলো ২বার XOR করবো। 
ফলে বাকি অংশ ০ হয়ে যাবে। শুধুমাত্র SubArray এর XOR উত্তরে পাবো। 
